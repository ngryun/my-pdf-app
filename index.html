<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF 영어 문장 추출기 (궈네 전용)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- PDF.js 라이브러리 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <!-- JSZip: HWPX(Zip/XML) 해석용 -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        // PDF.js가 백그라운드에서 작동하는 데 필요한 worker 스크립트 경로를 설정합니다.
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }
        /* 결과 영역의 스타일을 지정합니다. */
        #result-container p {
            margin-bottom: 0.75rem; /* 각 문장 아래에 여백 추가 */
            line-height: 1.6;     /* 줄 간격 조절 */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <!-- 메인 컨테이너 -->
    <div class="w-full max-w-2xl p-8 space-y-6 bg-white rounded-xl shadow-lg">
        
        <!-- 헤더 -->
        <div class="sm:flex sm:items-center sm:justify-between text-center sm:text-left">
            <div>
                <h1 class="text-3xl font-bold text-gray-900">PDF 영어 문장 추출기 (궈네 전용)</h1>
                <p class="mt-2 text-sm text-gray-600">PDF를 업로드하면 AI가 완전한 영어 문장만 추출합니다.</p>
            </div>
            <img 
                src="image1.png" 
                alt="개발자 이미지" 
                class="mt-4 sm:mt-0 sm:ml-4 rounded-lg shadow object-contain h-[4.5rem] w-auto mx-auto sm:mx-0 shrink-0"
            />
        </div>
        
        <!-- 파일 업로드 폼 -->
        <div class="space-y-4">
            <div class="space-y-2">
                <label for="pdf-upload" class="sr-only">PDF 파일 업로드</label>
                <input id="pdf-upload" name="pdf" type="file" accept=".pdf,.hwpx" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 transition">
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                <button id="extract-btn" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition disabled:bg-indigo-300">
                    <svg id="btn-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M2.5 17a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1Z"></path><path d="M6.5 17a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1Z"></path><path d="M10.5 17a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1Z"></path></svg>
                    <span id="btn-text">문장 추출하기</span>
                </button>
                <button id="scramble-btn" class="w-full flex justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-indigo-700 bg-indigo-50 hover:bg-indigo-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition disabled:bg-gray-200 disabled:text-gray-500">
                    문장 섞기 (Scramble)
                </button>
            </div>
        </div>
        
        <!-- 결과 표시 영역 -->
        <div class="mt-6 p-6 border border-gray-200 rounded-lg bg-gray-50 min-h-[200px]">
             <div id="status-container" class="flex items-center justify-center h-full">
                 <div id="loader" class="hidden animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                 <p id="status-text" class="text-gray-600 text-center">직접 문장을 입력하거나 추출 결과가 여기에 채워집니다.</p>
            </div>
            <div id="result-container" class="text-left text-gray-800 divide-y divide-gray-200"></div>
        </div>

        <!-- 섞은 문장 표시 영역 -->
        <div class="mt-6 p-6 border border-gray-200 rounded-lg bg-gray-50 min-h-[120px]">
            <p class="text-sm text-gray-600 mb-3">[문장 섞기]를 누르면 아래에 섞은 문장이 표시됩니다.</p>
            <div id="scrambled-container" class="text-left text-gray-800"></div>
        </div>

        <!-- 안내문 -->
        <div class="mt-4 p-4 border border-gray-200 rounded-lg bg-gray-50">
            <div>
                <h2 class="text-sm font-semibold text-gray-700">안내문</h2>
                <p class="mt-1 text-sm text-gray-600">개발: 남궁연(설악고등학교)</p>
            </div>
        </div>
    </div>

    <script type="module">
        // Gemini API 라이브러리를 가져옵니다.
        // 불필요: 클라이언트에서 Gemini 직접 호출하지 않음
        // import { GoogleGenerativeAI } from "https://cdn.jsdelivr.net/npm/@google/generative-ai/+esm";

        // HTML 요소들을 변수에 할당합니다.
        const extractBtn = document.getElementById('extract-btn');
        const pdfUpload = document.getElementById('pdf-upload');
        const statusContainer = document.getElementById('status-container');
        const resultContainer = document.getElementById('result-container');
        const loader = document.getElementById('loader');
        const statusText = document.getElementById('status-text');
        const btnText = document.getElementById('btn-text');
        const scrambleBtn = document.getElementById('scramble-btn');
        const scrambledContainer = document.getElementById('scrambled-container');

        // 상태: 마지막으로 추출된 문장들
        let lastExtractedSentences = [];

        // 유틸: 서버가 "문장1. ..." 형태로 보낸 경우 번호 제거
        function stripKoreanNumbering(line) {
            return (line || '').replace(/^\s*문장\s*\d+\.?\s*/i, '').trim();
        }

        // 유틸: Fisher-Yates 셔플
        function shuffleArray(arr) {
            const a = arr.slice();
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        // 유틸: 문장 단어 무작위 섞기
        function scrambleSentence(sentence) {
            if (!sentence) return '';
            // 앞/뒤 따옴표 등 최소 보존
            const prefixMatch = sentence.match(/^(["'“‘(\[]*)/);
            const suffixMatch = sentence.match(/(["'”’)\]]*)$/);
            const prefix = prefixMatch ? prefixMatch[1] : '';
            const suffix = suffixMatch ? suffixMatch[1] : '';

            // 끝의 마침표/물음표/느낌표 묶음 보존
            const endPuncMatch = sentence.replace(prefix, '').replace(suffix, '').match(/([.!?]+)\s*$/);
            const endPunc = endPuncMatch ? endPuncMatch[1] : '';

            // 본문 텍스트 추출(양끝 불필요 문자 제거)
            let core = sentence.trim();
            if (prefix) core = core.slice(prefix.length);
            if (suffix) core = core.slice(0, core.length - suffix.length);
            if (endPunc) core = core.replace(new RegExp(`[${endPunc.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')}]\s*$`), '');

            // 쉼표/세미콜론 등은 제거하여 단어만 섞음
            core = core.replace(/[,:;]+/g, ' ');
            const words = core.split(/\s+/).filter(Boolean);
            if (words.length <= 1) return sentence; // 한 단어면 그대로

            const shuffled = shuffleArray(words);
            const scrambled = `${prefix}${shuffled.join(' ')}${endPunc}${suffix}`.trim();
            return scrambled;
        }

        // HTML 이스케이프
        function escapeHtml(str = '') {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // 편집 가능한 문장 입력 렌더링(노트 라인 스타일)
        function renderSentenceInputs(sentences = []) {
            const minLines = 6; // 기본 라인 수(노트 느낌)
            const values = Array.from({ length: Math.max(sentences.length, minLines) }, (_, i) => sentences[i] || '');
            resultContainer.innerHTML = values
                .map((val, idx) => `
                    <div class="flex items-center gap-3 py-2">
                        <label class="shrink-0 w-14 text-xs font-medium text-gray-600 select-none">문장${idx + 1}</label>
                        <input
                            type="text"
                            class="flex-1 bg-transparent text-sm text-gray-800 placeholder-gray-400 outline-none focus:outline-none focus:ring-0 appearance-none py-1"
                            placeholder="여기에 문장을 입력하세요"
                            value="${escapeHtml(val)}"
                        />
                    </div>
                `)
                .join('');
        }

        // 입력 필드에서 문장 값 수집
        function getSentencesFromInputs() {
            const nodes = resultContainer.querySelectorAll('input[type="text"]');
            return Array.from(nodes).map(t => (t.value || '').trim()).filter(Boolean);
        }

        // 섞기 버튼 클릭 이벤트
        scrambleBtn.addEventListener('click', () => {
            const sentences = getSentencesFromInputs();
            if (!sentences.length) {
                scrambledContainer.innerHTML = '<p class="text-gray-600">위 입력칸에 문장을 직접 입력하거나 PDF에서 추출해주세요.</p>';
                return;
            }
            const scrambled = sentences.map(scrambleSentence);
            scrambledContainer.innerHTML = scrambled
                .map((s, idx) => `<p><strong>문장${idx + 1}.</strong> ${s.trim()}</p>`)
                .join('');
        });
        

        // HWPX 텍스트 추출 (Zip/XML)
        async function extractTextFromHwpx(arrayBuffer) {
            statusText.textContent = 'HWPX 파일 해석 중(압축 해제)...';
            const zip = await JSZip.loadAsync(arrayBuffer);

            // 우선순위: Contents/ 아래의 section*.xml, 없으면 모든 .xml
            let xmlNames = Object.keys(zip.files)
                .filter(n => n.toLowerCase().endsWith('.xml'));
            const contentsXml = xmlNames.filter(n => /(^|\/)contents\//i.test(n));
            if (contentsXml.length) xmlNames = contentsXml;

            // section 순서대로 정렬
            xmlNames.sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

            const parser = new DOMParser();

            function isExcludedElementName(name) {
                const n = (name || '').toLowerCase();
                // 네임스페이스 접두어 제거 후도 검사
                const base = n.includes(':') ? n.split(':')[1] : n;
                const hay = `${n} ${base}`;
                return (
                    /header|footer/.test(hay) ||
                    /(foot|end)note/.test(hay) ||
                    /comment|annotation/.test(hay) ||
                    /meta|head/.test(hay) ||
                    /tblof|toc/.test(hay)
                );
            }

            function isLikelyTextParent(name) {
                const n = (name || '').toLowerCase();
                const base = n.includes(':') ? n.split(':')[1] : n;
                const hay = `${n} ${base}`;
                return /(^|\b)(p|para|run|text|span|t|char|line)(\b|$)/.test(hay);
            }

            function collectFilteredText(doc) {
                const parts = [];
                const walker = doc.createTreeWalker(doc, NodeFilter.SHOW_TEXT, {
                    acceptNode(node) {
                        const raw = (node.nodeValue || '').replace(/[\s\u00A0]+/g, ' ').trim();
                        if (!raw) return NodeFilter.FILTER_REJECT;
                        // 제외 영역에 속하는지 확인
                        let el = node.parentNode;
                        let hasTextParent = false;
                        while (el && el.nodeType === 1) {
                            const tag = el.tagName || '';
                            if (isExcludedElementName(tag)) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            if (!hasTextParent && isLikelyTextParent(tag)) {
                                hasTextParent = true;
                            }
                            el = el.parentNode;
                        }
                        // 문단/러닝텍스트 하위가 아니면 비중 낮게 취급 — 허용은 하되 후처리에서 줄바꿈 없이 결합
                        return NodeFilter.FILTER_ACCEPT;
                    }
                });
                let node;
                while ((node = walker.nextNode())) {
                    const txt = (node.nodeValue || '').replace(/[\s\u00A0]+/g, ' ').trim();
                    if (txt) parts.push(txt);
                }
                // 문장 경계를 살리기 위해 공백 합치고 과도한 공백 제거
                return parts.join(' ').replace(/\s+/g, ' ').trim();
            }

            const texts = [];
            for (let i = 0; i < xmlNames.length; i++) {
                const name = xmlNames[i];
                statusText.textContent = `HWPX XML 읽는 중... (${i + 1}/${xmlNames.length})`;
                const xmlString = await zip.file(name).async('text');
                const doc = parser.parseFromString(xmlString, 'text/xml');
                if (!doc || !doc.documentElement) continue;
                // 본문 위주로 텍스트 수집
                const filtered = collectFilteredText(doc);
                if (filtered) texts.push(filtered);
            }

            return texts.join(' ').replace(/\s+/g, ' ').trim();
        }

        // '문장 추출하기' 버튼 클릭 이벤트 리스너
        extractBtn.addEventListener('click', async () => {
            const file = pdfUpload.files[0];
            if (!file) {
                statusText.textContent = '먼저 파일을 선택해주세요. (PDF/HWPX)';
                return;
            }

            // UI를 로딩 상태로 변경합니다.
            loader.classList.remove('hidden');
            statusText.textContent = '파일을 분석 중입니다...';
            resultContainer.innerHTML = '';
            scrambledContainer.innerHTML = '';
            extractBtn.disabled = true;
            btnText.textContent = '추출 중...';
            scrambleBtn.disabled = true;
            
            try {
                const fileReader = new FileReader();
                
                fileReader.onload = async (event) => {
                    try {
                        const arrayBuffer = event.target.result;
                        const name = (file.name || '').toLowerCase();
                        let allText = '';

                        if (name.endsWith('.pdf')) {
                            const typedarray = new Uint8Array(arrayBuffer);
                            const pdf = await pdfjsLib.getDocument(typedarray).promise;
                            for (let i = 1; i <= pdf.numPages; i++) {
                                statusText.textContent = `${pdf.numPages} 페이지 중 ${i} 페이지를 읽는 중...`;
                                const page = await pdf.getPage(i);
                                const textContent = await page.getTextContent();
                                allText += textContent.items.map(item => item.str).join(' ');
                            }
                        } else if (name.endsWith('.hwpx')) {
                            allText = await extractTextFromHwpx(arrayBuffer);
                        } else {
                            throw new Error('지원하지 않는 파일 형식입니다. PDF 또는 HWPX를 선택해주세요.');
                        }

                        statusText.textContent = '추출된 텍스트를 AI로 분석 중입니다...';

                        // Gemini API에 보낼 프롬프트
                        const prompt = `From the following text, extract only the complete English sentences. List each sentence on a new line. Do not add any numbering, bullet points, or introductory text.\n\n---\n\nTEXT: "${allText}"`;

                        // Gemini API 호출
                        // 서버리스 함수에 POST 요청을 보냅니다.
                        const response = await fetch('/.netlify/functions/getSentences', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ text: allText }), // 추출한 텍스트를 전송
                        });

                        if (!response.ok) {
                            throw new Error('서버리스 함수 호출에 실패했습니다.');
                        }

                        const data = await response.json();
                        const aiResponseText = data.sentences; // 서버리스 함수가 보내준 결과

                        // API 응답을 줄바꿈 기준으로 나누어 문장 배열 생성
                        const rawLines = aiResponseText.split('\n').filter(s => s.trim() !== '');
                        // 서버에서 번호를 붙여 보낼 수 있으므로 내부 상태는 번호 제거
                        const englishSentences = rawLines.map(stripKoreanNumbering).filter(Boolean);

                        // 결과를 화면에 표시합니다.
                        if (englishSentences.length > 0) {
                            renderSentenceInputs(englishSentences.map(s => s.trim()));
                            statusText.textContent = `총 ${englishSentences.length}개의 영어 문장을 찾았습니다. 필요하면 직접 수정하세요.`;
                            lastExtractedSentences = englishSentences;
                            scrambleBtn.disabled = false;
                        } else {
                            statusText.textContent = 'AI가 PDF에서 완전한 영어 문장을 찾지 못했습니다. 직접 입력해도 됩니다.';
                            renderSentenceInputs(['', '']);
                            lastExtractedSentences = [];
                            scrambleBtn.disabled = false;
                        }

                    } catch (err) {
                        console.error('Processing Error:', err);
                        statusText.textContent = `처리 중 오류가 발생했습니다: ${err.message}`;
                    } finally {
                        // 처리가 끝나면 UI 복원
                        loader.classList.add('hidden');
                        extractBtn.disabled = false;
                        btnText.textContent = '문장 추출하기';
                        // 상태 영역은 안내 문구만 남겨두기
                    }
                };

                fileReader.onerror = () => {
                    throw new Error('파일을 읽는 중 오류가 발생했습니다.');
                };
                
                fileReader.readAsArrayBuffer(file);

            } catch (error) {
                console.error('Error:', error);
                statusText.textContent = `오류가 발생했습니다: ${error.message}`;
                loader.classList.add('hidden');
                extractBtn.disabled = false;
                btnText.textContent = '문장 추출하기';
                // 오류 시에도 직접 입력할 수 있게 기본 필드 제공
                if (!resultContainer.children.length) {
                    renderSentenceInputs(['', '']);
                }
            }
        });

        // 초기: 빈 편집 필드 두 개 표시
        renderSentenceInputs(['', '']);
    </script>
</body>
</html>

